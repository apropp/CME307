
% Helper function to run SOCP relaxation solver on given inputs
% Input: 
% - A: anchor locations 
% - D: distance matrix 
% - M: matrix indicating which i, j pairs for which distance is known
% - d: dimensionality of sensors/anchors
% - n_sensors: number of sensors
% - n_anchors: number of anchors
% - Z: predicted sensor locations
% Output:
% - obj: objective value 
function grad = nll_obj_grad(A, D, M, d, n_sensors, n_anchors, Z)
    % Mask for indication of membership in N_x.
    M_x = triu(ones(n_sensors, n_sensors)) - eye(n_sensors); 
    M_x = (M_x & M(n_anchors+1:end, n_anchors+1:end)); 
    % Mask for indication of membership in N_a.
    M_a = M(n_anchors+1:end, 1:n_anchors);
    
    Z = reshape(Z, [d*n_sensors, 1]); 
    A = reshape(A, [d*n_anchors, 1]); 
    grad = zeros(2*n_sensors, 1); 
    [E_s, E_a] = element_error(Z, A, D, d, n_sensors, n_anchors); 
    
    W_s = 
    
    for t = 1:n_sensors
        grad(2*t-1) = 4*sum(E_s(t,:).* W_s(2*t-1,:)) -...
            4*sum(E_s(:,t).*W_s(:,2*t-1))+...
            4*sum(E_a(t,:).*W_a(2*t-1,:));
        grad(2*t) = 4*sum(E_s(t,:).* W_s(2*t,:)) -...
            4*sum(E_s(:,t).*W_s(:,2*t))+...
            4*sum(E_a(t,:).*W_a(2*t,:));
    end
end
